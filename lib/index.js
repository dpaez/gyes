/**
 * The bloody blank page.
 * Never stop.
 * Dont even halt on.
 * Instead, go on and on and on.
 *
 * codename: Gyes
 * main module.
 *
 */

/**
 * @module Gyes
 */

/**
 * Module dependencies
 */
var debug = require('debug')('gyes');
var SocketClient = require( 'socket.io-client' );
var messaging = require( './messaging' );

/**
 * Module exports
 */

module.exports = Gyes; // Gyes == codename

module.exports.io = SocketClient;

module.exports.Interpretation = require( './interpretation' );

module.exports.Modality = require( './modality' );

module.exports.ModalityDriver = require( './modalityDriver' );

module.exports.Fusion = require( './fusion' );

module.exports.Fission = require( './fission' );

/**
 * Module constructor
 * @constructor
 * @param {string} app_key  A required app key.
 * @param {string} uri  An optional server uri.
 * @param {object} opts An optional options object.
 */
function Gyes( app_key, uri, opts ){
  if ( !app_key ){ throw new Error( 'A key is required.' ); }

  if ( !(this instanceof Gyes) ) return new Gyes( uri, opts );

  opts = opts || {};
  this.globalInterpretations = true;
  if ('boolean' === typeof opts.globalInterpretations){
    this.globalInterpretations = opts.globalInterpretations;
  }
  this.modalities = [];
  this.throttle = 0;
  try{
    this.io = SocketClient.connect( uri, opts );
  }catch( e ){
    throw Error(e);
  }

  // internal listeners - signals are an alternative
  messaging.on( 'gyes::recognize', this.emitSignal.bind(this) ); // when modality driver instance recognizes
  messaging.on( 'interpretation::trigger', this.emitInterpretation.bind(this) );
  // plusultra listeners
  this.io.on( 'plusultra::broadcast_new_modality', this.newModality.bind(this) );
  this.io.on( 'plusultra::broadcast_modality_signal', this.newSignal.bind(this) );
  this.io.on( 'plusultra::broadcast_interpretation', this.distributedInterpretation.bind(this) );
  // define message system
  this.messageSystem = ( this.globalInterpretations ) ? this.io : messaging;

}

/**
 * Module API
 */

Gyes.prototype.connect = function( uri, opts ){
  return this.io.connect( uri, opts );
};

Gyes.prototype.authenticate = function( key ){
  this.io.emit( 'authenticate', {token: key} );
};

Gyes.prototype.addModality = function( app_key, aModality ){

  // check modality prototype for specific methods, like a factory
  var isValid = this.isValidModality( aModality );
  if ( isValid ){
    // propagate the new modality | send app_key too?
    // this.io.emit( 'plusultra::new_modality', {'modality': aModality} );
    this.modalities.push( aModality );
  }else{
    throw new Error( 'There are some required methods not implemented yet. Verify your modality driver.' );
  }

};

Gyes.prototype.isValidModality = function( aModality ){
  var proto = aModality.prototype;

  // TODO: check this, it does not work this way anymore.
/*
  var hasType = ( (proto.modalityType) && ('string' === typeof proto.modalityType) );
  var isRecognizer = ( (proto.recognized) && ('function' === typeof proto.recognized) );
  var isSynthetizer = ( (proto.syntethize) && ('function' === typeof proto.syntethize) );

  return ( hasType && (isRecognizer || isSynthetizer) );
*/
  return true;
};

/**
 * emitSignal Distributes a modality generated signal to be consumed by the (distributed) Fusion module.
 * @param  {Object} data Modality signal data object.
 * @private
 */
Gyes.prototype.emitSignal = function( data ){
  debug( 'gyes::emitSignal' );
  this.io.emit( 'plusultra::modality_signal', {'signal':data} );
};

/**
 * emitInterpretation Distributes an interpretation generated by Fusion module to be catched by Fission engines.
 * @param  {Object} interpretation An Interpretation object.
 * @private
 */
Gyes.prototype.emitInterpretation = function( interpretation ){
  debug( 'gyes::emitInterpretation' );
  messaging.emit( 'gyes::interpretation', {'interpretation':interpretation} );

  if ( this.globalInterpretations ){
    this.io.emit( 'plusultra::interpretation', {'interpretation':JSON.stringify(interpretation)} );
  }

  if ( interpretation.canSynth ){
    var synths =  interpretation.synths;
    for ( var i = 0; i < synths.length; i++ ){
      var synthData = synths[ i ];
      // local messaging
      messaging.emit( 'gyes::synthesize', synthData );
    }
  }
};

/**
 * distributedInterpretation An interpretation generated elsewhere and shared through the platform.
 * @param  {Object} data An Interpretation object.
 * @private
 */
Gyes.prototype.distributedInterpretation = function( data ){
  debug( 'gyes::distributedInterpretation' );
  var interpretation = JSON.parse(data.interpretation);
  console.log( 'distributedInterpretation::interpretation is ', interpretation );
  messaging.emit( 'gyes::interpretation', {'interpretation':interpretation} );

  if ( interpretation.canSynth ){
    var synths =  interpretation.synths;
    for ( var i = 0; i < synths.length; i++ ){
      var synthData = synths[ i ];
      // local messaging
      console.log( 'synthData is:', synthData );
      messaging.emit( 'gyes::synthesize', synthData );
    }
  }
};

/**
 * newModality
 * @param  {Object} data A new modality object.
 * @private
 * @deprecated Add no value to distribute a ghost modality. At least not for production, maybe useful for log/stats.
 */
Gyes.prototype.newModality = function( data ){
  // this should be a set
  var newMod = data.modality;
  var exists = false;
  for ( var i = this.modalities.length - 1; i >= 0; i-- ) {
    if ( this.modalities[i] == newMod ){
      exists = true;
    }
  }
  if ( !exists ){
    this.modalities.push( data.modality );
    // signal the fusion module ?
  }
};

/**
 * newSignal Handles a broadcasted signal (which happened on any other client). Fuels the fusion system.
 * @param  {Object} data A signal representation.
 * @private
 */
Gyes.prototype.newSignal = function( data ){
  debug( 'gyes::newSignal: %s', data );
  //if ( this.throttle % 3 === 0 ){
  messaging.emit( 'gyes::new_signal', data.signal );
  //}
  this.throttle++;
};